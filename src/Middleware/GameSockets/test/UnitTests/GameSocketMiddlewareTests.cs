// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Net;
using System.Net.Http;
using System.Net.GameSockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Contoso.GameNetCore.Testing;
using Contoso.GameNetCore.Testing.xunit;
using Contoso.GameNetCore.GameSockets.Internal;
using Microsoft.Extensions.Logging.Testing;
using Xunit;

namespace Contoso.GameNetCore.GameSockets.Test
{
    public class GameSocketMiddlewareTests : LoggedTest
    {
        [Fact]
        public async Task Connect_Success()
        {
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, async context =>
            {
                Assert.True(context.GameSockets.IsGameSocketRequest);
                var gameSocket = await context.GameSockets.AcceptGameSocketAsync();
            }))
            using (var client = new ClientGameSocket())
                await client.ConnectAsync(new Uri($"ws://localhost:{port}/"), CancellationToken.None);
        }

        [Fact]
        public async Task NegotiateSubProtocol_Success()
        {
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, async context =>
            {
                Assert.True(context.GameSockets.IsGameSocketRequest);
                Assert.Equal("alpha, bravo, charlie", context.Request.Headers["Sec-GameSocket-Protocol"]);
                var gameSocket = await context.GameSockets.AcceptGameSocketAsync("Bravo");
            }))
            using (var client = new ClientGameSocket())
            {
                client.Options.AddSubProtocol("alpha");
                client.Options.AddSubProtocol("bravo");
                client.Options.AddSubProtocol("charlie");
                await client.ConnectAsync(new Uri($"ws://localhost:{port}/"), CancellationToken.None);

                // The Windows version of ClientGameSocket uses the casing from the header (Bravo)
                // However, the Managed version seems match the header against the list generated by
                // the AddSubProtocol calls (case-insensitively) and then use the version from
                // that list as the value for SubProtocol. This is fine, but means we need to ignore case here.
                // We could update our AddSubProtocols above to the same case but I think it's better to
                // ensure this behavior is codified by this test.
                Assert.Equal("Bravo", client.SubProtocol, ignoreCase: true);
            }
        }

        [Fact]
        public async Task SendEmptyData_Success()
        {
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, async context =>
            {
                Assert.True(context.GameSockets.IsGameSocketRequest);
                var gameSocket = await context.GameSockets.AcceptGameSocketAsync();

                var serverBuffer = new byte[0];
                var result = await gameSocket.ReceiveAsync(new ArraySegment<byte>(serverBuffer), CancellationToken.None);
                Assert.True(result.EndOfMessage);
                Assert.Equal(0, result.Count);
                Assert.Equal(GameSocketMessageType.Binary, result.MessageType);
            }))
            using (var client = new ClientGameSocket())
            {
                await client.ConnectAsync(new Uri($"ws://localhost:{port}/"), CancellationToken.None);
                var originalData = new byte[0];
                await client.SendAsync(new ArraySegment<byte>(originalData), GameSocketMessageType.Binary, true, CancellationToken.None);
            }
        }

        [Fact]
        public async Task SendShortData_Success()
        {
            var originalData = Encoding.UTF8.GetBytes("Hello World");
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, async context =>
            {
                Assert.True(context.GameSockets.IsGameSocketRequest);
                var gameSocket = await context.GameSockets.AcceptGameSocketAsync();

                var serverBuffer = new byte[originalData.Length];
                var result = await gameSocket.ReceiveAsync(new ArraySegment<byte>(serverBuffer), CancellationToken.None);
                Assert.True(result.EndOfMessage);
                Assert.Equal(originalData.Length, result.Count);
                Assert.Equal(GameSocketMessageType.Binary, result.MessageType);
                Assert.Equal(originalData, serverBuffer);
            }))
            using (var client = new ClientGameSocket())
            {
                await client.ConnectAsync(new Uri($"ws://localhost:{port}/"), CancellationToken.None);
                await client.SendAsync(new ArraySegment<byte>(originalData), GameSocketMessageType.Binary, true, CancellationToken.None);
            }
        }

        [Fact]
        public async Task SendMediumData_Success()
        {
            var originalData = Encoding.UTF8.GetBytes(new string('a', 130));
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, async context =>
            {
                Assert.True(context.GameSockets.IsGameSocketRequest);
                var gameSocket = await context.GameSockets.AcceptGameSocketAsync();

                var serverBuffer = new byte[originalData.Length];
                var result = await gameSocket.ReceiveAsync(new ArraySegment<byte>(serverBuffer), CancellationToken.None);
                Assert.True(result.EndOfMessage);
                Assert.Equal(originalData.Length, result.Count);
                Assert.Equal(GameSocketMessageType.Binary, result.MessageType);
                Assert.Equal(originalData, serverBuffer);
            }))
            using (var client = new ClientGameSocket())
            {
                await client.ConnectAsync(new Uri($"ws://localhost:{port}/"), CancellationToken.None);
                await client.SendAsync(new ArraySegment<byte>(originalData), GameSocketMessageType.Binary, true, CancellationToken.None);
            }
        }

        [Fact]
        public async Task SendLongData_Success()
        {
            var originalData = Encoding.UTF8.GetBytes(new string('a', 0x1FFFF));
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, async context =>
            {
                Assert.True(context.GameSockets.IsGameSocketRequest);
                var gameSocket = await context.GameSockets.AcceptGameSocketAsync();

                var serverBuffer = new byte[originalData.Length];
                var result = await gameSocket.ReceiveAsync(new ArraySegment<byte>(serverBuffer), CancellationToken.None);
                int intermediateCount = result.Count;
                Assert.False(result.EndOfMessage);
                Assert.Equal(GameSocketMessageType.Text, result.MessageType);

                result = await gameSocket.ReceiveAsync(new ArraySegment<byte>(serverBuffer, intermediateCount, originalData.Length - intermediateCount), CancellationToken.None);
                intermediateCount += result.Count;
                Assert.False(result.EndOfMessage);
                Assert.Equal(GameSocketMessageType.Text, result.MessageType);

                result = await gameSocket.ReceiveAsync(new ArraySegment<byte>(serverBuffer, intermediateCount, originalData.Length - intermediateCount), CancellationToken.None);
                intermediateCount += result.Count;
                Assert.True(result.EndOfMessage);
                Assert.Equal(originalData.Length, intermediateCount);
                Assert.Equal(GameSocketMessageType.Text, result.MessageType);

                Assert.Equal(originalData, serverBuffer);
            }))
            using (var client = new ClientGameSocket())
            {
                await client.ConnectAsync(new Uri($"ws://localhost:{port}/"), CancellationToken.None);
                await client.SendAsync(new ArraySegment<byte>(originalData), GameSocketMessageType.Binary, true, CancellationToken.None);
            }
        }

        [Fact]
        public async Task SendFragmentedData_Success()
        {
            var originalData = Encoding.UTF8.GetBytes("Hello World");
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, async context =>
            {
                Assert.True(context.GameSockets.IsGameSocketRequest);
                var gameSocket = await context.GameSockets.AcceptGameSocketAsync();

                var serverBuffer = new byte[originalData.Length];
                var result = await gameSocket.ReceiveAsync(new ArraySegment<byte>(serverBuffer), CancellationToken.None);
                Assert.False(result.EndOfMessage);
                Assert.Equal(2, result.Count);
                var totalReceived = result.Count;
                Assert.Equal(GameSocketMessageType.Binary, result.MessageType);

                result = await gameSocket.ReceiveAsync(
                    new ArraySegment<byte>(serverBuffer, totalReceived, serverBuffer.Length - totalReceived), CancellationToken.None);
                Assert.False(result.EndOfMessage);
                Assert.Equal(2, result.Count);
                totalReceived += result.Count;
                Assert.Equal(GameSocketMessageType.Binary, result.MessageType);

                result = await gameSocket.ReceiveAsync(
                    new ArraySegment<byte>(serverBuffer, totalReceived, serverBuffer.Length - totalReceived), CancellationToken.None);
                Assert.True(result.EndOfMessage);
                Assert.Equal(7, result.Count);
                totalReceived += result.Count;
                Assert.Equal(GameSocketMessageType.Binary, result.MessageType);

                Assert.Equal(originalData, serverBuffer);
            }))
            using (var client = new ClientGameSocket())
            {
                await client.ConnectAsync(new Uri($"ws://localhost:{port}/"), CancellationToken.None);
                await client.SendAsync(new ArraySegment<byte>(originalData, 0, 2), GameSocketMessageType.Binary, false, CancellationToken.None);
                await client.SendAsync(new ArraySegment<byte>(originalData, 2, 2), GameSocketMessageType.Binary, false, CancellationToken.None);
                await client.SendAsync(new ArraySegment<byte>(originalData, 4, 7), GameSocketMessageType.Binary, true, CancellationToken.None);
            }
        }

        [Fact]
        public async Task ReceiveShortData_Success()
        {
            var originalData = Encoding.UTF8.GetBytes("Hello World");
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, async context =>
            {
                Assert.True(context.GameSockets.IsGameSocketRequest);
                var gameSocket = await context.GameSockets.AcceptGameSocketAsync();

                await gameSocket.SendAsync(new ArraySegment<byte>(originalData), GameSocketMessageType.Binary, true, CancellationToken.None);
            }))
            using (var client = new ClientGameSocket())
            {
                await client.ConnectAsync(new Uri($"ws://localhost:{port}/"), CancellationToken.None);
                var clientBuffer = new byte[originalData.Length];
                var result = await client.ReceiveAsync(new ArraySegment<byte>(clientBuffer), CancellationToken.None);
                Assert.True(result.EndOfMessage);
                Assert.Equal(originalData.Length, result.Count);
                Assert.Equal(GameSocketMessageType.Binary, result.MessageType);
                Assert.Equal(originalData, clientBuffer);
            }
        }

        [Fact]
        public async Task ReceiveMediumData_Success()
        {
            var originalData = Encoding.UTF8.GetBytes(new string('a', 130));
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, async context =>
            {
                Assert.True(context.GameSockets.IsGameSocketRequest);
                var gameSocket = await context.GameSockets.AcceptGameSocketAsync();

                await gameSocket.SendAsync(new ArraySegment<byte>(originalData), GameSocketMessageType.Binary, true, CancellationToken.None);
            }))
            using (var client = new ClientGameSocket())
            {
                await client.ConnectAsync(new Uri($"ws://localhost:{port}/"), CancellationToken.None);
                var clientBuffer = new byte[originalData.Length];
                var result = await client.ReceiveAsync(new ArraySegment<byte>(clientBuffer), CancellationToken.None);
                Assert.True(result.EndOfMessage);
                Assert.Equal(originalData.Length, result.Count);
                Assert.Equal(GameSocketMessageType.Binary, result.MessageType);
                Assert.Equal(originalData, clientBuffer);
            }
        }

        [Fact]
        public async Task ReceiveLongData()
        {
            var originalData = Encoding.UTF8.GetBytes(new string('a', 0x1FFFF));
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, async context =>
            {
                Assert.True(context.GameSockets.IsGameSocketRequest);
                var gameSocket = await context.GameSockets.AcceptGameSocketAsync();

                await gameSocket.SendAsync(new ArraySegment<byte>(originalData), GameSocketMessageType.Binary, true, CancellationToken.None);
            }))
            using (var client = new ClientGameSocket())
            {
                await client.ConnectAsync(new Uri($"ws://localhost:{port}/"), CancellationToken.None);
                var clientBuffer = new byte[originalData.Length];
                GameSocketReceiveResult result;
                var receivedCount = 0;
                do
                {
                    result = await client.ReceiveAsync(new ArraySegment<byte>(clientBuffer, receivedCount, clientBuffer.Length - receivedCount), CancellationToken.None);
                    receivedCount += result.Count;
                    Assert.Equal(GameSocketMessageType.Binary, result.MessageType);
                }
                while (!result.EndOfMessage);

                Assert.Equal(originalData.Length, receivedCount);
                Assert.Equal(GameSocketMessageType.Binary, result.MessageType);
                Assert.Equal(originalData, clientBuffer);
            }
        }

        [Fact]
        public async Task ReceiveFragmentedData_Success()
        {
            var originalData = Encoding.UTF8.GetBytes("Hello World");
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, async context =>
            {
                Assert.True(context.GameSockets.IsGameSocketRequest);
                var gameSocket = await context.GameSockets.AcceptGameSocketAsync();

                await gameSocket.SendAsync(new ArraySegment<byte>(originalData, 0, 2), GameSocketMessageType.Binary, false, CancellationToken.None);
                await gameSocket.SendAsync(new ArraySegment<byte>(originalData, 2, 2), GameSocketMessageType.Binary, false, CancellationToken.None);
                await gameSocket.SendAsync(new ArraySegment<byte>(originalData, 4, 7), GameSocketMessageType.Binary, true, CancellationToken.None);
            }))
            using (var client = new ClientGameSocket())
            {
                await client.ConnectAsync(new Uri($"ws://localhost:{port}/"), CancellationToken.None);
                var clientBuffer = new byte[originalData.Length];
                var result = await client.ReceiveAsync(new ArraySegment<byte>(clientBuffer), CancellationToken.None);
                Assert.False(result.EndOfMessage);
                Assert.Equal(2, result.Count);
                var totalReceived = result.Count;
                Assert.Equal(GameSocketMessageType.Binary, result.MessageType);

                result = await client.ReceiveAsync(
                    new ArraySegment<byte>(clientBuffer, totalReceived, clientBuffer.Length - totalReceived), CancellationToken.None);
                Assert.False(result.EndOfMessage);
                Assert.Equal(2, result.Count);
                totalReceived += result.Count;
                Assert.Equal(GameSocketMessageType.Binary, result.MessageType);

                result = await client.ReceiveAsync(
                    new ArraySegment<byte>(clientBuffer, totalReceived, clientBuffer.Length - totalReceived), CancellationToken.None);
                Assert.True(result.EndOfMessage);
                Assert.Equal(7, result.Count);
                totalReceived += result.Count;
                Assert.Equal(GameSocketMessageType.Binary, result.MessageType);

                Assert.Equal(originalData, clientBuffer);
            }
        }

        [Fact]
        public async Task SendClose_Success()
        {
            var closeDescription = "Test Closed";
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, async context =>
            {
                Assert.True(context.GameSockets.IsGameSocketRequest);
                var gameSocket = await context.GameSockets.AcceptGameSocketAsync();

                var serverBuffer = new byte[1024];
                var result = await gameSocket.ReceiveAsync(new ArraySegment<byte>(serverBuffer), CancellationToken.None);
                Assert.True(result.EndOfMessage);
                Assert.Equal(0, result.Count);
                Assert.Equal(GameSocketMessageType.Close, result.MessageType);
                Assert.Equal(GameSocketCloseStatus.NormalClosure, result.CloseStatus);
                Assert.Equal(closeDescription, result.CloseStatusDescription);
            }))
            using (var client = new ClientGameSocket())
            {
                await client.ConnectAsync(new Uri($"ws://localhost:{port}/"), CancellationToken.None);
                await client.CloseOutputAsync(GameSocketCloseStatus.NormalClosure, closeDescription, CancellationToken.None);

                Assert.Equal(GameSocketState.CloseSent, client.State);
            }
        }

        [Fact]
        public async Task ReceiveClose_Success()
        {
            var closeDescription = "Test Closed";
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, async context =>
            {
                Assert.True(context.GameSockets.IsGameSocketRequest);
                var gameSocket = await context.GameSockets.AcceptGameSocketAsync();

                await gameSocket.CloseOutputAsync(GameSocketCloseStatus.NormalClosure, closeDescription, CancellationToken.None);
            }))
            using (var client = new ClientGameSocket())
            {
                await client.ConnectAsync(new Uri($"ws://localhost:{port}/"), CancellationToken.None);
                var clientBuffer = new byte[1024];
                var result = await client.ReceiveAsync(new ArraySegment<byte>(clientBuffer), CancellationToken.None);
                Assert.True(result.EndOfMessage);
                Assert.Equal(0, result.Count);
                Assert.Equal(GameSocketMessageType.Close, result.MessageType);
                Assert.Equal(GameSocketCloseStatus.NormalClosure, result.CloseStatus);
                Assert.Equal(closeDescription, result.CloseStatusDescription);

                Assert.Equal(GameSocketState.CloseReceived, client.State);
            }
        }

        [Fact]
        public async Task CloseFromOpen_Success()
        {
            var closeDescription = "Test Closed";
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, async context =>
            {
                Assert.True(context.GameSockets.IsGameSocketRequest);
                var gameSocket = await context.GameSockets.AcceptGameSocketAsync();

                var serverBuffer = new byte[1024];
                var result = await gameSocket.ReceiveAsync(new ArraySegment<byte>(serverBuffer), CancellationToken.None);
                Assert.True(result.EndOfMessage);
                Assert.Equal(0, result.Count);
                Assert.Equal(GameSocketMessageType.Close, result.MessageType);
                Assert.Equal(GameSocketCloseStatus.NormalClosure, result.CloseStatus);
                Assert.Equal(closeDescription, result.CloseStatusDescription);

                await gameSocket.CloseAsync(result.CloseStatus.Value, result.CloseStatusDescription, CancellationToken.None);
            }))
            using (var client = new ClientGameSocket())
            {
                await client.ConnectAsync(new Uri($"ws://localhost:{port}/"), CancellationToken.None);
                await client.CloseAsync(GameSocketCloseStatus.NormalClosure, closeDescription, CancellationToken.None);

                Assert.Equal(GameSocketState.Closed, client.State);
            }
        }

        [Fact]
        public async Task CloseFromCloseSent_Success()
        {
            var closeDescription = "Test Closed";
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, async context =>
            {
                Assert.True(context.GameSockets.IsGameSocketRequest);
                var gameSocket = await context.GameSockets.AcceptGameSocketAsync();

                var serverBuffer = new byte[1024];
                var result = await gameSocket.ReceiveAsync(new ArraySegment<byte>(serverBuffer), CancellationToken.None);
                Assert.True(result.EndOfMessage);
                Assert.Equal(0, result.Count);
                Assert.Equal(GameSocketMessageType.Close, result.MessageType);
                Assert.Equal(GameSocketCloseStatus.NormalClosure, result.CloseStatus);
                Assert.Equal(closeDescription, result.CloseStatusDescription);

                await gameSocket.CloseAsync(result.CloseStatus.Value, result.CloseStatusDescription, CancellationToken.None);
            }))
            using (var client = new ClientGameSocket())
            {
                await client.ConnectAsync(new Uri($"ws://localhost:{port}/"), CancellationToken.None);
                await client.CloseOutputAsync(GameSocketCloseStatus.NormalClosure, closeDescription, CancellationToken.None);
                Assert.Equal(GameSocketState.CloseSent, client.State);

                await client.CloseAsync(GameSocketCloseStatus.NormalClosure, closeDescription, CancellationToken.None);
                Assert.Equal(GameSocketState.Closed, client.State);
            }
        }

        [Fact]
        public async Task CloseFromCloseReceived_Success()
        {
            var closeDescription = "Test Closed";
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, async context =>
            {
                Assert.True(context.GameSockets.IsGameSocketRequest);
                var gameSocket = await context.GameSockets.AcceptGameSocketAsync();

                await gameSocket.CloseOutputAsync(GameSocketCloseStatus.NormalClosure, closeDescription, CancellationToken.None);

                var serverBuffer = new byte[1024];
                var result = await gameSocket.ReceiveAsync(new ArraySegment<byte>(serverBuffer), CancellationToken.None);
                Assert.True(result.EndOfMessage);
                Assert.Equal(0, result.Count);
                Assert.Equal(GameSocketMessageType.Close, result.MessageType);
                Assert.Equal(GameSocketCloseStatus.NormalClosure, result.CloseStatus);
                Assert.Equal(closeDescription, result.CloseStatusDescription);
            }))
            using (var client = new ClientGameSocket())
            {
                await client.ConnectAsync(new Uri($"ws://localhost:{port}/"), CancellationToken.None);
                var clientBuffer = new byte[1024];
                var result = await client.ReceiveAsync(new ArraySegment<byte>(clientBuffer), CancellationToken.None);
                Assert.True(result.EndOfMessage);
                Assert.Equal(0, result.Count);
                Assert.Equal(GameSocketMessageType.Close, result.MessageType);
                Assert.Equal(GameSocketCloseStatus.NormalClosure, result.CloseStatus);
                Assert.Equal(closeDescription, result.CloseStatusDescription);

                Assert.Equal(GameSocketState.CloseReceived, client.State);

                await client.CloseAsync(result.CloseStatus.Value, result.CloseStatusDescription, CancellationToken.None);

                Assert.Equal(GameSocketState.Closed, client.State);
            }
        }

        [Theory]
        [InlineData(HttpStatusCode.OK, null)]
        [InlineData(HttpStatusCode.Forbidden, "")]
        [InlineData(HttpStatusCode.Forbidden, "http://e.com")]
        [InlineData(HttpStatusCode.OK, "http://e.com", "http://example.com")]
        [InlineData(HttpStatusCode.OK, "*")]
        [InlineData(HttpStatusCode.OK, "http://e.com", "*")]
        [InlineData(HttpStatusCode.OK, "http://ExAmPLE.cOm")]
        public async Task OriginIsValidatedForGameSocketRequests(HttpStatusCode expectedCode, params string[] origins)
        {
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, context =>
            {
                Assert.True(context.GameSockets.IsGameSocketRequest);
                return Task.CompletedTask;
            },
            o =>
            {
                if (origins != null)
                    foreach (var origin in origins)
                        o.AllowedOrigins.Add(origin);
            }))
            using (var client = new HttpClient())
            {
                var uri = new UriBuilder(new Uri($"ws://localhost:{port}/"))
                {
                    Scheme = "http"
                };

                // Craft a valid GameSocket Upgrade request
                using (var request = new HttpRequestMessage(HttpMethod.Get, uri.ToString()))
                {
                    request.Headers.Connection.Clear();
                    request.Headers.Connection.Add("Upgrade");
                    request.Headers.Upgrade.Add(new System.Net.Http.Headers.ProductHeaderValue("gamesocket"));
                    request.Headers.Add(Constants.Headers.SecGameSocketVersion, Constants.Headers.SupportedVersion);
                    // SecGameSocketKey required to be 16 bytes
                    request.Headers.Add(Constants.Headers.SecGameSocketKey, Convert.ToBase64String(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 }, Base64FormattingOptions.None));

                    request.Headers.Add("Origin", "http://example.com");

                    var response = await client.SendAsync(request);
                    Assert.Equal(expectedCode, response.StatusCode);
                }
            }
        }

        [Fact]
        [Flaky("https://github.com/aspnet/AspNetCore/issues/8187", FlakyOn.Helix.All)]
        public async Task OriginIsNotValidatedForNonGameSocketRequests()
        {
            using (var server = KestrelGameSocketHelpers.CreateServer(LoggerFactory, out var port, context =>
            {
                Assert.False(context.GameSockets.IsGameSocketRequest);
                return Task.CompletedTask;
            },
            o => o.AllowedOrigins.Add("http://example.com")))
            using (var client = new HttpClient())
            {
                var uri = new UriBuilder(new Uri($"ws://localhost:{port}/"))
                {
                    Scheme = "http"
                };

                using (var request = new HttpRequestMessage(HttpMethod.Get, uri.ToString()))
                {
                    request.Headers.Add("Origin", "http://notexample.com");

                    var response = await client.SendAsync(request);
                    Assert.Equal(HttpStatusCode.OK, response.StatusCode);
                }
            }
        }
    }
}
